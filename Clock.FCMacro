# v2.0.4 – 2025-11-21 - Final Spacing & Height Adjustments
# Fixed: Full space row between zone dropdown and time in global clock
# Fixed: Maximum heights added to all sections for consistency
# Fixed: 1 row separators between all sections (1px visible line)

__Name__ = 'CLOCK'
__Comment__ = 'Clock,Timer, Alarm ,Countdown,Pomodoro, Exam mode'
__Author__ = 'AI Assistant + Imagineer'
__Version__ = '2.0.4'
__Date__ = '2025-11-21'
__License__ = 'MIT'
__Web__ = 'www.youtube.com/@imagine7547'
__Wiki__ = 'https://github.com/wpegley/CLOCK'
__Icon__ = ''
__Help__ = ''
__Status__ = 'Stable'
__Requires__ = 'FreeCAD >= v1.1'

import FreeCAD as App
import FreeCADGui as Gui
from PySide import QtGui, QtCore
import datetime
import time
import os
import sys
import shutil
import tempfile
import platform
import subprocess
import glob

# --- Try to import openpyxl for XLSX export ---
try:
    from openpyxl import Workbook, load_workbook
    from openpyxl.styles import Font, Alignment
    OPENPYXL_AVAILABLE = True
except ImportError:
    OPENPYXL_AVAILABLE = False
    print("Warning: openpyxl not found. XLSX export disabled.")

# --- Global Time Zones (expanded) ---
GLOBAL_ZONES = {
    # Oceania
    "Sydney, AU (AEST/AEDT)": 10,   # base offset; DST applied below
    "Melbourne, AU (AEST/AEDT)": 10,
    "Brisbane, AU (AEST)": 10,
    "Perth, AU (AWST)": 8,
    "Auckland, NZ (NZST/NZDT)": 12,

    # Asia
    "Tokyo, Japan (JST)": 9,
    "Seoul, Korea (KST)": 9,
    "Shanghai, China (CST)": 8,
    "Singapore (SGT)": 8,
    "Hong Kong (HKT)": 8,
    "Bangkok, Thailand (ICT)": 7,
    "New Delhi, India (IST)": 5.5,
    "Dubai, UAE (GST)": 4,

    # Europe
    "London, UK (GMT/BST)": 0,
    "Paris, France (CET/CEST)": 1,
    "Berlin, Germany (CET/CEST)": 1,
    "Madrid, Spain (CET/CEST)": 1,
    "Rome, Italy (CET/CEST)": 1,
    "Moscow, Russia (MSK)": 3,

    # Africa
    "Cape Town, South Africa (SAST)": 2,
    "Nairobi, Kenya (EAT)": 3,

    # Americas
    "New York, USA (EST/EDT)": -5,
    "Chicago, USA (CST/CDT)": -6,
    "Denver, USA (MST/MDT)": -7,
    "Los Angeles, USA (PST/PDT)": -8,
    "Toronto, Canada (EST/EDT)": -5,
    "São Paulo, Brazil (BRT)": -3,

    # Odd offsets
    "Kathmandu, Nepal (NPT)": 5.75,
    "Yangon, Myanmar (MMT)": 6.5,
    "Tehran, Iran (IRST)": 3.5,
}


def _apply_simple_dst(utc_dt, zone_name, base_offset):
    """Return local datetime with a simple, hard-coded DST adjustment.

    This intentionally avoids external tz libraries; it only handles
    a few common regions where the macro is likely to be used.
    """
    offset = base_offset

    # Australia (Sydney / Melbourne): first Sunday in October at 2 AM to
    # first Sunday in April at 3 AM (next year), +1 hour.
    if "Sydney" in zone_name or "Melbourne" in zone_name:
        year = utc_dt.year
        # First Sunday in October at 2 AM AEST (which is 16:00 UTC day before)
        first_oct = datetime.datetime(year, 10, 1)
        first_oct_wd = first_oct.weekday()  # Mon=0..Sun=6
        days_to_sun = (6 - first_oct_wd) % 7
        dst_start_local = first_oct + datetime.timedelta(days=days_to_sun, hours=2)
        dst_start_utc = dst_start_local - datetime.timedelta(hours=base_offset)

        # First Sunday in April NEXT YEAR at 3 AM AEDT (which is 16:00 UTC day before)
        first_apr = datetime.datetime(year + 1, 4, 1)
        first_apr_wd = first_apr.weekday()
        days_to_sun_apr = (6 - first_apr_wd) % 7
        dst_end_local = first_apr + datetime.timedelta(days=days_to_sun_apr, hours=3)
        dst_end_utc = dst_end_local - datetime.timedelta(hours=base_offset + 1)

        # DST is active if we're after October start OR before April end
        # Since it spans across the year boundary
        if dst_start_utc <= utc_dt < dst_end_utc:
            offset += 1

    # New Zealand (Auckland): last Sunday in September at 2 AM to
    # first Sunday in April at 3 AM, +1 hour.
    if "Auckland" in zone_name:
        year = utc_dt.year
        # Last Sunday in September at 2 AM NZST
        last_sep = datetime.datetime(year, 10, 1) - datetime.timedelta(days=1)  # Sept 30
        last_sep_wd = last_sep.weekday()
        days_back = (last_sep_wd - 6) % 7
        dst_start_local = last_sep - datetime.timedelta(days=days_back, hours=-2)
        dst_start_utc = dst_start_local - datetime.timedelta(hours=base_offset)

        # First Sunday in April at 3 AM NZDT
        first_apr = datetime.datetime(year, 4, 1)
        first_apr_wd = first_apr.weekday()
        days_to_sun_apr = (6 - first_apr_wd) % 7
        dst_end_local = first_apr + datetime.timedelta(days=days_to_sun_apr, hours=3)
        dst_end_utc = dst_end_local - datetime.timedelta(hours=base_offset + 1)

        if dst_start_utc <= utc_dt < dst_end_utc:
            offset += 1

    return utc_dt + datetime.timedelta(hours=offset)


class ProjectTimeTrackerPanel:
    """Main panel class for the FreeCAD Clock & Time Tracker dock."""
    
    def get_form(self):
        return self.form

    def create_title_label(self, text):
        label = QtGui.QLabel(text)
        label.setFont(self.font_title)
        return label

    def get_open_documents(self):
        try:
            docs = list(App.listDocuments().keys())
            return docs if docs else ["No Document"]
        except Exception:
            return ["No Document"]

    def get_default_xlsx_path(self):
        current_path = os.path.abspath(__file__)
        root_dir = current_path
        max_levels = 10
        levels = 0
        while os.path.basename(root_dir) != 'Macro_Directory' and levels < max_levels:
            parent = os.path.dirname(root_dir)
            if parent == root_dir:
                break
            root_dir = parent
            levels += 1
        if os.path.basename(root_dir) == 'Macro_Directory':
            data_folder = os.path.join(root_dir, 'Macro_03', 'Technical_Data')
            os.makedirs(data_folder, exist_ok=True)
            path = os.path.join(data_folder, "Project_Time_Data.xlsx")
            self.macro_directory_root = root_dir  # Store for relative path display
            print(f"Using relative path: {path}")
            return path
        else:
            self.macro_directory_root = None
            fallback = os.path.join(App.getUserAppDataDir(), "Project_Time_Data.xlsx")
            print(f"Macro_Directory not found. Using fallback: {fallback}")
            return fallback

    def get_display_path(self):
        """Return relative path for display if inside Macro_Directory"""
        if self.macro_directory_root and self.default_xlsx_path.startswith(self.macro_directory_root):
            rel_path = os.path.relpath(self.default_xlsx_path, self.macro_directory_root)
            return f"Macro_Directory/{rel_path.replace(os.sep, '/')}"
        return self.default_xlsx_path

    def load_existing_data(self):
        if not OPENPYXL_AVAILABLE:
            return
        path = self.default_xlsx_path
        if not os.path.exists(path):
            return
        try:
            wb = load_workbook(path)
            if 'Alarm' not in wb.sheetnames:
                wb.create_sheet('Alarm')
                wb.save(path)
            sheet_name = "Time_Log"
            if sheet_name not in wb.sheetnames:
                return
            ws = wb[sheet_name]
            self.project_times = {}
            for row in ws.iter_rows(min_row=2, values_only=True):
                if row[0] and row[1] and row[2]:
                    proj = str(row[0])
                    dur = str(row[1])
                    ts = str(row[2])
                    self.project_times.setdefault(proj, []).append((dur, ts))
            print(f"Loaded {sum(len(v) for v in self.project_times.values())} entries")
        except Exception as e:
            print(f"Load error: {e}")

    def auto_save_to_xlsx(self):
        if not OPENPYXL_AVAILABLE:
            return
        path = self.default_xlsx_path
        try:
            if os.path.exists(path):
                shutil.copy2(path, path + ".bak")
            temp_dir = os.path.dirname(path)
            fd, temp_path = tempfile.mkstemp(suffix=".xlsx", dir=temp_dir)
            os.close(fd)

            wb = load_workbook(path) if os.path.exists(path) else Workbook()
            sheet_name = "Time_Log"
            if sheet_name in wb.sheetnames:
                ws = wb[sheet_name]
                ws.delete_rows(2, ws.max_row)
            else:
                ws = wb.create_sheet(sheet_name)
                if 'Sheet' in wb.sheetnames and wb['Sheet'].max_row == 1:
                    del wb['Sheet']

            header = ["Project Name", "Duration (HH:MM:SS)", "Date & Time Logged"]
            for col, txt in enumerate(header, 1):
                cell = ws.cell(1, col)
                cell.value = txt
                cell.font = Font(bold=True)
                cell.alignment = Alignment(horizontal='center')

            row_idx = 2
            for proj in sorted(self.project_times.keys()):
                for dur, ts in self.project_times[proj]:
                    ws.cell(row_idx, 1).value = proj
                    ws.cell(row_idx, 2).value = dur
                    ws.cell(row_idx, 3).value = ts
                    row_idx += 1

            for col_idx, col_letter in enumerate(['A', 'B', 'C'], 1):
                ws.column_dimensions[col_letter].width = 20

            wb.save(temp_path)
            if os.path.exists(path):
                os.remove(path)
            shutil.move(temp_path, path)
            print(f"Saved {row_idx - 2} entries to {path}")
        except Exception as e:
            print(f"Save error: {e}")
            if os.path.exists(temp_path):
                try:
                    os.remove(temp_path)
                except:
                    pass

    def _populate_alarm_sounds(self):
        self._alarm_sound_files = []
        try:
            win_dir = os.path.join(os.environ.get('WINDIR', 'C:\\Windows'), 'Media')
            if os.path.isdir(win_dir):
                wavs = glob.glob(os.path.join(win_dir, '*.wav'))
                self._alarm_sound_files = sorted(wavs)
        except Exception as e:
            print(f"Error loading alarm sounds: {e}")
        
        self.alarm_sound_selector.clear()
        if self._alarm_sound_files:
            for f in self._alarm_sound_files:
                self.alarm_sound_selector.addItem(os.path.basename(f))
            self.alarm_sound_preview_btn.setEnabled(True)
        else:
            self.alarm_sound_selector.addItem("(No sounds found)")
            self.alarm_sound_preview_btn.setEnabled(False)

    def _populate_countdown_sounds(self):
        self._countdown_sound_files = []
        try:
            win_dir = os.path.join(os.environ.get('WINDIR', 'C:\\Windows'), 'Media')
            if os.path.isdir(win_dir):
                wavs = glob.glob(os.path.join(win_dir, '*.wav'))
                self._countdown_sound_files = sorted(wavs)
        except Exception:
            pass
        if not self._countdown_sound_files:
            self._countdown_sound_files = ["(No sounds found)"]
        self.countdown_sound_selector.clear()
        for f in self._countdown_sound_files:
            self.countdown_sound_selector.addItem(os.path.basename(f))

    def _populate_pomodoro_sounds(self):
        self._pomodoro_sound_files = []
        try:
            win_dir = os.path.join(os.environ.get('WINDIR', 'C:\\Windows'), 'Media')
            if os.path.isdir(win_dir):
                wavs = glob.glob(os.path.join(win_dir, '*.wav'))
                self._pomodoro_sound_files = sorted(wavs)
        except Exception:
            pass
        if not self._pomodoro_sound_files:
            self._pomodoro_sound_files = ["(No sounds found)"]
        self.pomodoro_focus_sound_selector.clear()
        self.pomodoro_break_sound_selector.clear()
        for f in self._pomodoro_sound_files:
            basename = os.path.basename(f)
            self.pomodoro_focus_sound_selector.addItem(basename)
            self.pomodoro_break_sound_selector.addItem(basename)

    def __init__(self):
        self.form = QtGui.QWidget()
        self.dock_widget = None  # Will be set by main when dock is created
        
        # Create main layout with static header sections and scrollable content
        main_container_layout = QtGui.QVBoxLayout(self.form)
        main_container_layout.setContentsMargins(0, 0, 0, 0)
        main_container_layout.setSpacing(0)
        
        # Static header layout for checkbox row and clock (stays visible at top)
        self.static_header_layout = QtGui.QVBoxLayout()
        self.static_header_layout.setContentsMargins(2, 2, 2, 0)
        self.static_header_layout.setSpacing(1)
        main_container_layout.addLayout(self.static_header_layout)
        
        # Add scroll area to handle remaining sections
        self.scroll_area = QtGui.QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.scroll_area.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
        self.scroll_area.setFrameShape(QtGui.QFrame.NoFrame)
        
        # Create scrollable content widget
        self.content_widget = QtGui.QWidget()
        self.main_layout = QtGui.QVBoxLayout(self.content_widget)
        # Tight spacing throughout
        self.main_layout.setContentsMargins(2, 1, 2, 2)
        self.main_layout.setSpacing(1)
        
        self.scroll_area.setWidget(self.content_widget)
        main_container_layout.addWidget(self.scroll_area)

        # Standardized font system for consistent GUI appearance
        # Title font: Section headers
        self.font_title = QtGui.QFont()
        self.font_title.setPointSize(10)
        self.font_title.setBold(True)
        
        # Label font: Field labels and descriptions
        self.font_label = QtGui.QFont()
        self.font_label.setPointSize(9)
        
        # Display font: All time/clock displays (standardized)
        self.font_display = QtGui.QFont("Monospace")
        self.font_display.setPointSize(16)
        self.font_display.setBold(True)
        
        # Status font: Status messages and info text
        self.font_status = QtGui.QFont()
        self.font_status.setPointSize(9)
        
        # Button font: All buttons (inherit system, but ensure consistency)
        self.font_button = QtGui.QFont()
        self.font_button.setPointSize(9)
        self.font_button.setBold(True)

        self.macro_directory_root = None
        self.default_xlsx_path = self.get_default_xlsx_path()
        self.project_times = {}
        self.load_existing_data()

        self.stopwatch_running = False
        self.stopwatch_time = 0.0
        self.stopwatch_start_time = 0.0

        self._alarm_last_fired_date = None

        self.countdown_running = False
        self.countdown_paused = False
        self.countdown_total_seconds = 600
        self.countdown_paused_remaining = 600
        self.countdown_end_time = 0.0

        self.pomodoro_running = False
        self.pomodoro_paused = False
        self.pomodoro_phase = 'focus'
        self.pomodoro_paused_remaining = 0
        self.pomodoro_end_time = 0.0

        self._pomodoro_sound_session_id = 0
        self._pomodoro_sound_remaining = 0
        self._pomodoro_current_sound_file = None

        self.exam_zone_index = 0

        self.cached_document_list = []

        self.setup_checkbox_row()
        self.setup_clock_section()
        self.setup_timer_section()
        self.setup_alarm_section()
        self.setup_countdown_section()
        self.setup_pomodoro_section()
        self.setup_exam_section()

        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.update_all)
        self.timer.start(100)

        self.form.destroyed.connect(self.cleanup)

    def setup_checkbox_row(self):
        row = QtGui.QGridLayout()
        row.setSpacing(6)
        switches = [
            ("Clock", True),
            ("Timer", True),
            ("Alarm", True),
            ("Countdown", False),
            ("Pomodoro", False),
            ("Exam", False),
        ]
        col = 0
        max_columns = 3  # wrap into 2 rows on narrow docks
        for idx, (name, checked) in enumerate(switches):
            cb = QtGui.QCheckBox(name)
            cb.setChecked(checked)
            cb.setFont(self.font_title)
            r = idx // max_columns
            c = idx % max_columns
            row.addWidget(cb, r, c)
            setattr(self, f"{name.lower()}_switch", cb)
        # Add to static header so it stays at top
        self.static_header_layout.addLayout(row)

    # -----------------------------------------------------------------------
    # Clock Section
    # -----------------------------------------------------------------------
    def setup_clock_section(self):
        self.clock_container = QtGui.QWidget()
        lay = QtGui.QVBoxLayout(self.clock_container)
        # FIXED: Tight spacing, no margins
        lay.setContentsMargins(2, 1, 2, 1)
        lay.setSpacing(1)

        # Lean button height at 26px
        self.clock_toggle_button = QtGui.QPushButton("Switch to Global Time")
        self.clock_toggle_button.setStyleSheet(
            "background-color:#55aaff;color:white;"
            "padding:3px 6px;min-height:22px;max-height:26px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.clock_toggle_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        self.clock_toggle_button.clicked.connect(self.toggle_clock_view)
        lay.addWidget(self.clock_toggle_button)

        self.clock_type_switch = QtGui.QStackedWidget()
        self.setup_area_1_local_clock_view()
        self.setup_area_2_global_clock_view()
        lay.addWidget(self.clock_type_switch)

        # Increased heights for international clock display
        self.clock_type_switch.setMaximumHeight(60)
        # Increased overall height for better spacing
        self.clock_container.setMaximumHeight(95)
        
        self.update_toggle_button_text(0)
        self.clock_switch.stateChanged.connect(self.clock_container.setVisible)
        # Add to static header so it stays at top
        self.static_header_layout.addWidget(self.clock_container)
        # Separator between static header and scrollable content
        sep = QtGui.QFrame(frameShape=QtGui.QFrame.HLine)
        sep.setFixedHeight(1)
        sep.setFrameShape(QtGui.QFrame.HLine)
        sep.setStyleSheet("QFrame { border: none; background-color: #555; }")
        self.static_header_layout.addWidget(sep)

    def toggle_clock_view(self):
        idx = self.clock_type_switch.currentIndex()
        new_idx = 1 if idx == 0 else 0
        self.clock_type_switch.setCurrentIndex(new_idx)
        self.update_toggle_button_text(new_idx)
        self.clock_container.adjustSize()
        self.clock_container.updateGeometry()

    def update_toggle_button_text(self, idx):
        self.clock_toggle_button.setText(
            "Switch to Global Time" if idx == 0 else "Switch to Local Time"
        )

    def setup_area_1_local_clock_view(self):
        w = QtGui.QWidget()
        h = QtGui.QHBoxLayout(w)
        h.setContentsMargins(0, 0, 0, 0)
        h.setSpacing(8)

        self.local_time_label = QtGui.QLabel("00:00:00 PM")
        self.local_time_label.setFont(self.font_display)
        h.addWidget(self.local_time_label)

        self.local_date_label = QtGui.QLabel("Mon Jan 01")
        self.local_date_label.setFont(self.font_display)
        h.addWidget(self.local_date_label)

        self.clock_type_switch.addWidget(w)

    def setup_area_2_global_clock_view(self):
        w = QtGui.QWidget()
        v = QtGui.QVBoxLayout(w)
        # FIXED: Tight spacing, no extra spacers
        v.setContentsMargins(0, 0, 0, 0)
        v.setSpacing(1)

        h = QtGui.QHBoxLayout()
        h.setContentsMargins(0, 0, 0, 0)
        h.addWidget(self.create_title_label("Zone:"))
        self.global_zone_selector = QtGui.QComboBox()
        self.global_zone_selector.addItems(GLOBAL_ZONES.keys())
        self.global_zone_selector.setMaxVisibleItems(12)
        h.addWidget(self.global_zone_selector)
        v.addLayout(h)

        # Increased spacing between zone dropdown and time/date row
        v.addSpacing(8)

        h2 = QtGui.QHBoxLayout()
        h2.setContentsMargins(0, 0, 0, 0)
        h2.setSpacing(8)

        self.global_time_label = QtGui.QLabel("00:00:00 PM")
        self.global_time_label.setFont(self.font_display)
        h2.addWidget(self.global_time_label)

        self.global_date_label = QtGui.QLabel("Mon Jan 01")
        self.global_date_label.setFont(self.font_display)
        h2.addWidget(self.global_date_label)

        v.addLayout(h2)
        self.clock_type_switch.addWidget(w)

    # -----------------------------------------------------------------------
    # Timer Section – STOPWATCH
    # -----------------------------------------------------------------------
    def setup_timer_section(self):
        self.timer_container = QtGui.QWidget()
        lay = QtGui.QGridLayout(self.timer_container)
        # FIXED: Tight spacing throughout
        lay.setContentsMargins(2, 1, 2, 1)
        lay.setHorizontalSpacing(2)
        lay.setVerticalSpacing(1)

        row = 0
        lay.addWidget(self.create_title_label("Timer"), row, 0, 1, 2)
        row += 1

        self.stopwatch_display = QtGui.QLabel("00:00:00")
        self.stopwatch_display.setFont(self.font_display)
        self.stopwatch_display.setAlignment(QtCore.Qt.AlignCenter)
        self.stopwatch_display.setStyleSheet("background-color:#222;color:#4CAF50;padding:4px;border-radius:3px;")
        # Allow display to shrink horizontally with the dock
        self.stopwatch_display.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)
        lay.addWidget(self.stopwatch_display, row, 0, 1, 2)
        row += 1

        btns = QtGui.QGridLayout()
        btns.setHorizontalSpacing(2)
        btns.setVerticalSpacing(0)

        # Lean button heights at 24px
        self.stopwatch_start_button = QtGui.QPushButton("Start")
        self.stopwatch_start_button.clicked.connect(self.stopwatch_start)
        self.stopwatch_start_button.setStyleSheet(
            "background-color:#4CAF50;color:white;"
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.stopwatch_start_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.stopwatch_start_button, 0, 0)

        self.stopwatch_stop_button = QtGui.QPushButton("Stop")
        self.stopwatch_stop_button.clicked.connect(self.stopwatch_stop_and_log)
        self.stopwatch_stop_button.setStyleSheet(
            "background-color:#f44336;color:white;"
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.stopwatch_stop_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        self.stopwatch_stop_button.setEnabled(False)
        btns.addWidget(self.stopwatch_stop_button, 0, 1)

        self.stopwatch_reset_button = QtGui.QPushButton("Reset")
        self.stopwatch_reset_button.clicked.connect(self.stopwatch_reset)
        self.stopwatch_reset_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.stopwatch_reset_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.stopwatch_reset_button, 0, 2)

        lay.addLayout(btns, row, 0, 1, 2)
        row += 1

        proj_row = QtGui.QHBoxLayout()
        proj_row.setSpacing(2)
        proj_label = self.create_title_label("Project:")
        proj_label.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Preferred)
        proj_row.addWidget(proj_label)

        self.project_selector = QtGui.QComboBox()
        self.project_selector.setEditable(True)
        self.project_selector.addItems(self.get_open_documents())
        self.cached_document_list = self.get_open_documents()
        self.project_selector.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)
        # Keep dock visible after using dropdown
        self.project_selector.activated.connect(lambda: self._raise_dock_delayed())
        # Let project selector compress horizontally instead of forcing wide dock
        try:
            self.project_selector.setSizeAdjustPolicy(self.project_selector.AdjustToMinimumContentsLength)
            self.project_selector.setMinimumContentsLength(4)
        except Exception:
            # Older/variant Qt bindings may not expose this enum; fall back silently.
            pass
        proj_row.addWidget(self.project_selector)
        lay.addLayout(proj_row, row, 0, 1, 2)
        row += 1

        # Removed dedicated status row to keep timer section compact
        self.status_label = QtGui.QLabel("")
        self.status_label.setFont(self.font_status)
        self.status_label.setWordWrap(True)
        self.status_label.setStyleSheet("color:#aaa;")
        self.status_label.setSizePolicy(QtGui.QSizePolicy.Ignored, QtGui.QSizePolicy.Preferred)

        btn_row = QtGui.QGridLayout()
        btn_row.setHorizontalSpacing(2)
        btn_row.setVerticalSpacing(0)

        # Lean button heights at 24px
        self.view_logs_button = QtGui.QPushButton("Logs")
        self.view_logs_button.clicked.connect(self.view_logs)
        self.view_logs_button.setStyleSheet(
            "background-color:#2196F3;color:white;"
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.view_logs_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btn_row.addWidget(self.view_logs_button, 0, 0)

        self.edit_path_button = QtGui.QPushButton("Path")
        self.edit_path_button.clicked.connect(self.edit_file_path)
        self.edit_path_button.setStyleSheet(
            "background-color:#FFA500;color:black;"
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.edit_path_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btn_row.addWidget(self.edit_path_button, 0, 1)

        lay.addLayout(btn_row, row, 0, 1, 2)
        row += 1

        self.save_path_label = QtGui.QLabel(self.get_display_path())
        self.save_path_label.setFont(self.font_status)
        self.save_path_label.setWordWrap(True)
        self.save_path_label.setStyleSheet(
            "background-color:#4CAF50;color:white;padding:6px;"
            "border:1px solid #45a049;border-radius:4px;"
        )
        self.save_path_label.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
        lay.addWidget(self.save_path_label, row, 0, 1, 2)
        self.save_path_label.setMaximumHeight(self.save_path_label.fontMetrics().lineSpacing() * 5)

        # FIXED: Maximum height for timer section
        self.timer_container.setMaximumHeight(260)
        
        self.timer_switch.stateChanged.connect(self.timer_container.setVisible)
        self.main_layout.addWidget(self.timer_container)
        # FIXED: 1 row separator between sections
        sep_timer = QtGui.QFrame(frameShape=QtGui.QFrame.HLine)
        sep_timer.setFixedHeight(1)
        sep_timer.setFrameShape(QtGui.QFrame.HLine)
        sep_timer.setStyleSheet("QFrame { border: none; background-color: #555; }")
        self.main_layout.addWidget(sep_timer)

    # -----------------------------------------------------------------------
    # STOPWATCH METHODS
    # -----------------------------------------------------------------------
    def stopwatch_start(self):
        if not self.stopwatch_running:
            self.stopwatch_running = True
            self.stopwatch_start_time = time.monotonic() - self.stopwatch_time
            self.stopwatch_start_button.setEnabled(False)
            self.stopwatch_stop_button.setEnabled(True)
            self.status_label.setText("Timer running...")
            if getattr(self, '_pending_new_file', False):
                self._pending_new_file = False
                from openpyxl import Workbook
                wb = Workbook()
                wb.save(self.default_xlsx_path)
                self.status_label.setText(f"Created: {self.default_xlsx_path}")

    def stopwatch_stop_and_log(self):
        if not self.stopwatch_running:
            return
        proj = self.project_selector.currentText()
        if not proj:
            self.status_label.setText("Select project.")
            return
        elapsed = time.monotonic() - self.stopwatch_start_time
        if elapsed < 1.0:
            self.status_label.setText("Too short.")
            return
        h, m, s = int(elapsed // 3600), int((elapsed % 3600) // 60), int(elapsed % 60)
        time_str = f"{h:02d}:{m:02d}:{s:02d}"
        log_ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.project_times.setdefault(proj, []).append((time_str, log_ts))
        
        # Save data without losing focus
        try:
            self.auto_save_to_xlsx()
        except Exception as e:
            print(f"Save error: {e}")
        
        self.status_label.setText(f"Logged {time_str} to {proj}")
        self.stopwatch_reset()
        
        # Keep Clock tab visible after operation
        if self.dock_widget:
            QtCore.QTimer.singleShot(100, lambda: self.dock_widget.raise_())

    def stopwatch_reset(self):
        self.stopwatch_running = False
        self.stopwatch_time = 0.0
        self.stopwatch_start_time = 0.0
        self.stopwatch_display.setText("00:00:00")
        self.stopwatch_start_button.setEnabled(True)
        self.stopwatch_stop_button.setEnabled(False)
        self.status_label.setText("")

    def stopwatch_update_display(self):
        elapsed = time.monotonic() - self.stopwatch_start_time if self.stopwatch_running else self.stopwatch_time
        h, m, s = int(elapsed // 3600), int((elapsed % 3600) // 60), int(elapsed % 60)
        self.stopwatch_display.setText(f"{h:02d}:{m:02d}:{s:02d}")

    # -----------------------------------------------------------------------
    # Alarm Section
    # -----------------------------------------------------------------------
    def setup_alarm_section(self):
        self.alarm_container = QtGui.QWidget()
        lay = QtGui.QVBoxLayout(self.alarm_container)
        # FIXED: Tight spacing
        lay.setContentsMargins(2, 1, 2, 1)
        lay.setSpacing(1)

        self.alarm_enable_checkbox = QtGui.QCheckBox("Enable Alarm")
        self.alarm_enable_checkbox.setFont(self.font_label)
        self.alarm_enable_checkbox.stateChanged.connect(self.on_alarm_settings_changed)
        lay.addWidget(self.alarm_enable_checkbox)

        h = QtGui.QHBoxLayout()
        lbl_time = QtGui.QLabel("Time:")
        lbl_time.setFont(self.font_label)
        h.addWidget(lbl_time)
        self.alarm_time_edit = QtGui.QTimeEdit()
        self.alarm_time_edit.setDisplayFormat("HH:mm")
        self.alarm_time_edit.setTime(QtCore.QTime.currentTime())
        self.alarm_time_edit.timeChanged.connect(self.on_alarm_settings_changed)
        h.addWidget(self.alarm_time_edit)
        lay.addLayout(h)

        h = QtGui.QHBoxLayout()
        lbl_zone = QtGui.QLabel("Zone:")
        lbl_zone.setFont(self.font_label)
        h.addWidget(lbl_zone)
        self.alarm_zone_selector = QtGui.QComboBox()
        self.alarm_zone_selector.addItem("Local")
        self.alarm_zone_selector.addItems(GLOBAL_ZONES.keys())
        self.alarm_zone_selector.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        self.alarm_zone_selector.currentIndexChanged.connect(self.on_alarm_settings_changed)
        h.addWidget(self.alarm_zone_selector)
        lay.addLayout(h)

        h = QtGui.QHBoxLayout()
        lbl_sound = QtGui.QLabel("Sound:")
        lbl_sound.setFont(self.font_label)
        h.addWidget(lbl_sound)
        self.alarm_sound_selector = QtGui.QComboBox()
        self.alarm_sound_selector.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        h.addWidget(self.alarm_sound_selector)
        
        # Lean button height
        self.alarm_sound_preview_btn = QtGui.QPushButton("Preview")
        self.alarm_sound_preview_btn.setStyleSheet(
            "padding:2px 6px;min-height:20px;max-height:24px;"
            "border-radius:3px;"
        )
        self.alarm_sound_preview_btn.setSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed)
        self.alarm_sound_preview_btn.clicked.connect(self._toggle_preview_alarm_sound)
        h.addWidget(self.alarm_sound_preview_btn)
        lay.addLayout(h)
        self._populate_alarm_sounds()

        lbl_repeat = QtGui.QLabel("Repeat:")
        lbl_repeat.setFont(self.font_label)
        lay.addWidget(lbl_repeat)
        self.alarm_repeat_checkboxes = []
        days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        row = QtGui.QHBoxLayout()
        for d in days:
            cb = QtGui.QCheckBox(d)
            cb.setFont(self.font_label)
            cb.stateChanged.connect(self.on_alarm_settings_changed)
            self.alarm_repeat_checkboxes.append(cb)
            row.addWidget(cb)
        lay.addLayout(row)

        self.alarm_status_label = QtGui.QLabel("Alarm off")
        self.alarm_status_label.setFont(self.font_status)
        self.alarm_status_label.setStyleSheet("color:#ff5252;font-weight:bold;")
        lay.addWidget(self.alarm_status_label)

        self.alarm_time_remaining_label = QtGui.QLabel("")
        self.alarm_time_remaining_label.setFont(self.font_status)
        self.alarm_time_remaining_label.setStyleSheet("color:#007700;font-weight:bold;")
        lay.addWidget(self.alarm_time_remaining_label)

        self.alarm_list_label = QtGui.QLabel()
        self.alarm_list_label.setFont(self.font_status)
        self.alarm_list_label.setWordWrap(True)
        self.alarm_list_label.setStyleSheet(
            "background-color:#2b2b2b;color:#aaa;padding:3px;border:1px solid #444;"
        )
        lay.addWidget(self.alarm_list_label)

        # FIXED: Maximum height for alarm section
        self.alarm_container.setMaximumHeight(190)
        
        self.alarm_switch.stateChanged.connect(self.alarm_container.setVisible)
        self.main_layout.addWidget(self.alarm_container)
        # FIXED: 1 row separator between sections
        sep_alarm = QtGui.QFrame(frameShape=QtGui.QFrame.HLine)
        sep_alarm.setFixedHeight(1)
        sep_alarm.setFrameShape(QtGui.QFrame.HLine)
        sep_alarm.setStyleSheet("QFrame { border: none; background-color: #555; }")
        self.main_layout.addWidget(sep_alarm)

    # -----------------------------------------------------------------------
    # Countdown Section
    # -----------------------------------------------------------------------
    def setup_countdown_section(self):
        self.countdown_container = QtGui.QWidget()
        lay = QtGui.QVBoxLayout(self.countdown_container)
        # FIXED: Tight spacing
        lay.setContentsMargins(2, 1, 2, 1)
        lay.setSpacing(1)

        lay.addWidget(self.create_title_label("Countdown Timer"))

        h = QtGui.QHBoxLayout()
        lbl_dur = QtGui.QLabel("Duration:")
        lbl_dur.setFont(self.font_label)
        h.addWidget(lbl_dur)
        self.countdown_time_edit = QtGui.QTimeEdit()
        self.countdown_time_edit.setDisplayFormat("HH:mm:ss")
        self.countdown_time_edit.setTime(QtCore.QTime(0, 10, 0))
        self.countdown_time_edit.timeChanged.connect(self._on_countdown_time_changed)
        h.addWidget(self.countdown_time_edit)
        lay.addLayout(h)

        h = QtGui.QHBoxLayout()
        lbl_sound = QtGui.QLabel("Sound:")
        lbl_sound.setFont(self.font_label)
        h.addWidget(lbl_sound)
        self.countdown_sound_selector = QtGui.QComboBox()
        self.countdown_sound_selector.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        self._populate_countdown_sounds()
        h.addWidget(self.countdown_sound_selector)
        lay.addLayout(h)

        self.countdown_display = QtGui.QLabel("00:10:00")
        self.countdown_display.setFont(self.font_display)
        self.countdown_display.setAlignment(QtCore.Qt.AlignCenter)
        self.countdown_display.setStyleSheet("background-color:#222;color:#ff9800;padding:4px;border-radius:3px;")
        self.countdown_display.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)
        lay.addWidget(self.countdown_display)

        btns = QtGui.QHBoxLayout()
        btns.setSpacing(4)

        # Lean button heights at 24px
        self.countdown_start_button = QtGui.QPushButton("Start")
        self.countdown_start_button.clicked.connect(self.countdown_start)
        self.countdown_start_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.countdown_start_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.countdown_start_button)

        self.countdown_pause_button = QtGui.QPushButton("Pause")
        self.countdown_pause_button.clicked.connect(self.countdown_pause)
        self.countdown_pause_button.setEnabled(False)
        self.countdown_pause_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.countdown_pause_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.countdown_pause_button)

        self.countdown_reset_button = QtGui.QPushButton("Reset")
        self.countdown_reset_button.clicked.connect(self.countdown_reset)
        self.countdown_reset_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.countdown_reset_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.countdown_reset_button)

        self.countdown_stop_alarm_button = QtGui.QPushButton("Stop")
        self.countdown_stop_alarm_button.clicked.connect(self.stop_countdown_alarm)
        self.countdown_stop_alarm_button.setEnabled(False)
        self.countdown_stop_alarm_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.countdown_stop_alarm_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.countdown_stop_alarm_button)

        lay.addLayout(btns)

        self.countdown_status_label = QtGui.QLabel("")
        self.countdown_status_label.setFont(self.font_status)
        self.countdown_status_label.setStyleSheet("color:#aaa;")
        lay.addWidget(self.countdown_status_label)

        # FIXED: Maximum height for countdown section
        self.countdown_container.setMaximumHeight(170)

        self.countdown_switch.stateChanged.connect(self.countdown_container.setVisible)
        self.countdown_container.setVisible(False)
        self.main_layout.addWidget(self.countdown_container)
        # FIXED: 1 row separator between sections
        sep_countdown = QtGui.QFrame(frameShape=QtGui.QFrame.HLine)
        sep_countdown.setFixedHeight(1)
        sep_countdown.setFrameShape(QtGui.QFrame.HLine)
        sep_countdown.setStyleSheet("QFrame { border: none; background-color: #555; }")
        self.main_layout.addWidget(sep_countdown)

        self._on_countdown_time_changed()

    def _on_countdown_time_changed(self):
        t = self.countdown_time_edit.time()
        total = t.hour() * 3600 + t.minute() * 60 + t.second()
        self.countdown_total_seconds = total
        self.countdown_paused_remaining = total
        if self.countdown_running:
            self.countdown_running = False
            self.countdown_paused = False
            self.countdown_start_button.setEnabled(True)
            self.countdown_pause_button.setEnabled(False)
            self.countdown_pause_button.setText("Pause")
            self.countdown_status_label.setText("")
        self.countdown_update_display()

    def countdown_start(self):
        if self.countdown_total_seconds <= 0:
            self.countdown_status_label.setText("Set duration > 0.")
            return
        self.countdown_end_time = time.monotonic() + self.countdown_total_seconds
        self.countdown_running = True
        self.countdown_paused = False
        self.countdown_start_button.setEnabled(False)
        self.countdown_pause_button.setEnabled(True)
        self.countdown_pause_button.setText("Pause")
        self.countdown_status_label.setText("Countdown running...")
        self.countdown_update_display()

    def countdown_pause(self):
        if self.countdown_running and not self.countdown_paused:
            self.countdown_paused = True
            rem = self.countdown_end_time - time.monotonic()
            self.countdown_paused_remaining = max(0, rem)
            self.countdown_pause_button.setText("Resume")
            self.countdown_status_label.setText("Countdown paused.")
        elif self.countdown_running and self.countdown_paused:
            self.countdown_paused = False
            self.countdown_end_time = time.monotonic() + self.countdown_paused_remaining
            self.countdown_pause_button.setText("Pause")
            self.countdown_status_label.setText("Countdown running...")

    def countdown_reset(self):
        t = self.countdown_time_edit.time()
        total = t.hour() * 3600 + t.minute() * 60 + t.second()
        self.countdown_total_seconds = total
        self.countdown_paused_remaining = total
        self.countdown_running = False
        self.countdown_paused = False
        self.countdown_start_button.setEnabled(True)
        self.countdown_pause_button.setEnabled(False)
        self.countdown_pause_button.setText("Pause")
        self.countdown_status_label.setText("")
        self.countdown_update_display()

    def countdown_update_display(self):
        rem = (self.countdown_end_time - time.monotonic()
               if self.countdown_running and not self.countdown_paused
               else self.countdown_paused_remaining)
        rem = max(0, rem)
        h, m, s = int(rem // 3600), int((rem % 3600) // 60), int(rem % 60)
        self.countdown_display.setText(f"{h:02d}:{m:02d}:{s:02d}")

    def trigger_countdown_alarm(self):
        idx = self.countdown_sound_selector.currentIndex()
        sound_file = self._countdown_sound_files[idx] if 0 <= idx < len(self._countdown_sound_files) else None
        if sound_file:
            try:
                import winsound
                winsound.PlaySound(sound_file, winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_LOOP)
            except Exception as e:
                print(f"Sound error: {e}")

        msg = QtGui.QMessageBox(self.form)
        msg.setWindowTitle("Countdown Finished")
        msg.setText("Time's up!")
        stop_btn = msg.addButton("Stop Alarm", QtGui.QMessageBox.AcceptRole)
        msg.addButton(QtGui.QMessageBox.Ok)
        msg.exec()
        if msg.clickedButton() == stop_btn:
            self.stop_countdown_alarm()

    def stop_countdown_alarm(self):
        try:
            import winsound
            winsound.PlaySound(None, winsound.SND_PURGE)
        except:
            pass
        self.countdown_stop_alarm_button.setEnabled(False)

    # -----------------------------------------------------------------------
    # Pomodoro Section
    # -----------------------------------------------------------------------
    def setup_pomodoro_section(self):
        self.pomodoro_container = QtGui.QWidget()
        lay = QtGui.QVBoxLayout(self.pomodoro_container)
        # FIXED: Tight spacing
        lay.setContentsMargins(2, 1, 2, 1)
        lay.setSpacing(1)

        lay.addWidget(self.create_title_label("Pomodoro Timer"))

        h = QtGui.QHBoxLayout()
        h.addWidget(QtGui.QLabel("Focus:"))
        self.pomodoro_focus_time_edit = QtGui.QTimeEdit()
        self.pomodoro_focus_time_edit.setDisplayFormat("HH:mm:ss")
        self.pomodoro_focus_time_edit.setTime(QtCore.QTime(0, 45, 0))
        h.addWidget(self.pomodoro_focus_time_edit)
        lay.addLayout(h)

        h = QtGui.QHBoxLayout()
        h.addWidget(QtGui.QLabel("Break:"))
        self.pomodoro_break_time_edit = QtGui.QTimeEdit()
        self.pomodoro_break_time_edit.setDisplayFormat("HH:mm:ss")
        self.pomodoro_break_time_edit.setTime(QtCore.QTime(0, 5, 0))
        h.addWidget(self.pomodoro_break_time_edit)
        lay.addLayout(h)

        h = QtGui.QHBoxLayout()
        h.addWidget(QtGui.QLabel("Focus End:"))
        self.pomodoro_focus_sound_selector = QtGui.QComboBox()
        h.addWidget(self.pomodoro_focus_sound_selector)
        lay.addLayout(h)

        h = QtGui.QHBoxLayout()
        h.addWidget(QtGui.QLabel("Break End:"))
        self.pomodoro_break_sound_selector = QtGui.QComboBox()
        h.addWidget(self.pomodoro_break_sound_selector)
        lay.addLayout(h)

        h = QtGui.QHBoxLayout()
        h.addWidget(QtGui.QLabel("Play Count:"))
        self.pomodoro_play_count_spin = QtGui.QSpinBox()
        self.pomodoro_play_count_spin.setRange(1, 10)
        self.pomodoro_play_count_spin.setValue(1)
        h.addWidget(self.pomodoro_play_count_spin)
        lay.addLayout(h)

        self.pomodoro_display = QtGui.QLabel("00:45:00")
        self.pomodoro_display.setFont(self.font_display)
        self.pomodoro_display.setAlignment(QtCore.Qt.AlignCenter)
        self.pomodoro_display.setStyleSheet("background-color:#222;color:#e53935;padding:4px;border-radius:3px;")
        self.pomodoro_display.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Preferred)
        lay.addWidget(self.pomodoro_display)

        btns = QtGui.QHBoxLayout()
        btns.setSpacing(4)

        # Lean button heights at 24px for better proportion
        self.pomodoro_start_button = QtGui.QPushButton("Start")
        self.pomodoro_start_button.clicked.connect(self.pomodoro_start)
        self.pomodoro_start_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.pomodoro_start_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.pomodoro_start_button)

        self.pomodoro_pause_button = QtGui.QPushButton("Pause")
        self.pomodoro_pause_button.clicked.connect(self.pomodoro_pause_resume_stop)
        self.pomodoro_pause_button.setEnabled(False)
        self.pomodoro_pause_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.pomodoro_pause_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.pomodoro_pause_button)

        self.pomodoro_reset_button = QtGui.QPushButton("Reset")
        self.pomodoro_reset_button.clicked.connect(self.pomodoro_reset)
        self.pomodoro_reset_button.setStyleSheet(
            "padding:3px 6px;min-height:20px;max-height:24px;"
            "font-weight:bold;border-radius:3px;"
        )
        self.pomodoro_reset_button.setSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Fixed)
        btns.addWidget(self.pomodoro_reset_button)

        lay.addLayout(btns)

        self.pomodoro_status_label = QtGui.QLabel("")
        self.pomodoro_status_label.setFont(self.font_status)
        self.pomodoro_status_label.setStyleSheet("color:#aaa;")
        lay.addWidget(self.pomodoro_status_label)

        # FIXED: Maximum height for pomodoro section
        self.pomodoro_container.setMaximumHeight(210)

        self.pomodoro_switch.stateChanged.connect(self.pomodoro_container.setVisible)
        self.pomodoro_container.setVisible(False)
        self.main_layout.addWidget(self.pomodoro_container)
        # FIXED: 1 row separator between sections
        sep_pomodoro = QtGui.QFrame(frameShape=QtGui.QFrame.HLine)
        sep_pomodoro.setFixedHeight(1)
        sep_pomodoro.setFrameShape(QtGui.QFrame.HLine)
        sep_pomodoro.setStyleSheet("QFrame { border: none; background-color: #555; }")
        self.main_layout.addWidget(sep_pomodoro)

        self._populate_pomodoro_sounds()
        self.pomodoro_focus_time_edit.timeChanged.connect(self._pomodoro_time_changed)
        self.pomodoro_break_time_edit.timeChanged.connect(self._pomodoro_time_changed)

    def _pomodoro_time_changed(self):
        if not self.pomodoro_running:
            self.pomodoro_update_display()

    def pomodoro_start(self):
        t = (self.pomodoro_focus_time_edit.time() if self.pomodoro_phase == 'focus'
             else self.pomodoro_break_time_edit.time())
        total = t.hour() * 3600 + t.minute() * 60 + t.second()
        if total <= 0:
            self.pomodoro_status_label.setText("Set duration > 0.")
            return
        self.pomodoro_paused_remaining = total
        self.pomodoro_end_time = time.monotonic() + total
        self.pomodoro_running = True
        self.pomodoro_paused = False
        self.pomodoro_start_button.setEnabled(False)
        self.pomodoro_pause_button.setEnabled(True)
        self.pomodoro_pause_button.setText("Pause")
        self.pomodoro_status_label.setText(f"{self.pomodoro_phase.capitalize()} running...")
        self.pomodoro_update_display()

    def pomodoro_pause_resume_stop(self):
        if not self.pomodoro_running:
            return
        if self.pomodoro_paused:
            self.pomodoro_paused = False
            self.pomodoro_end_time = time.monotonic() + self.pomodoro_paused_remaining
            self.pomodoro_pause_button.setText("Pause")
            self.pomodoro_status_label.setText(f"{self.pomodoro_phase.capitalize()} running...")
            return
        self.pomodoro_paused = True
        rem = self.pomodoro_end_time - time.monotonic()
        self.pomodoro_paused_remaining = max(0, rem)

        self._pomodoro_sound_session_id += 1

        self.pomodoro_pause_button.setText("Resume")
        self.pomodoro_status_label.setText(f"{self.pomodoro_phase.capitalize()} paused.")
        QtCore.QTimer.singleShot(800, lambda: self._show_stop_if_still_paused())

    def _show_stop_if_still_paused(self):
        if self.pomodoro_paused:
            self.pomodoro_pause_button.setText("Stop")

    def pomodoro_reset(self):
        self.pomodoro_running = False
        self.pomodoro_paused = False
        self.pomodoro_phase = 'focus'
        self.pomodoro_start_button.setEnabled(True)
        self.pomodoro_pause_button.setEnabled(False)
        self.pomodoro_pause_button.setText("Pause")
        self.pomodoro_status_label.setText("")

        self._pomodoro_sound_session_id += 1
        self._pomodoro_sound_remaining = 0
        self._pomodoro_current_sound_file = None

        self.pomodoro_update_display()

    def pomodoro_update_display(self):
        rem = (self.pomodoro_end_time - time.monotonic()
               if self.pomodoro_running and not self.pomodoro_paused
               else self.pomodoro_paused_remaining)
        rem = max(0, rem)
        h, m, s = int(rem // 3600), int((rem % 3600) // 60), int(rem % 60)
        self.pomodoro_display.setText(f"{h:02d}:{m:02d}:{s:02d}")

    def trigger_pomodoro_sound(self, which):
        selector = (self.pomodoro_focus_sound_selector
                    if which == 'focus' else self.pomodoro_break_sound_selector)
        idx = selector.currentIndex()
        if not (0 <= idx < len(self._pomodoro_sound_files)):
            return

        sound_file = self._pomodoro_sound_files[idx]
        play_count = self.pomodoro_play_count_spin.value()

        self._pomodoro_sound_session_id += 1
        self._pomodoro_sound_remaining = play_count
        self._pomodoro_current_sound_file = sound_file

        self._pomodoro_play_next_sound(self._pomodoro_sound_session_id)

    def _pomodoro_play_next_sound(self, session_id):
        if session_id != self._pomodoro_sound_session_id:
            return

        if self._pomodoro_sound_remaining <= 0:
            return

        try:
            import winsound
            import wave

            sound_file = self._pomodoro_current_sound_file
            if not sound_file or not os.path.exists(sound_file):
                return

            with wave.open(sound_file, 'r') as wf:
                frames = wf.getnframes()
                rate = wf.getframerate()
                duration_ms = int((frames / float(rate)) * 1000)

            winsound.PlaySound(sound_file, winsound.SND_FILENAME | winsound.SND_ASYNC)
            self._pomodoro_sound_remaining -= 1

            QtCore.QTimer.singleShot(duration_ms + 50, lambda: self._pomodoro_play_next_sound(session_id))
        except Exception as e:
            print(f"Pomodoro sound error: {e}")

    def _pomodoro_switch_phase(self):
        if self.pomodoro_phase == 'focus':
            self.pomodoro_phase = 'break'
            t = self.pomodoro_break_time_edit.time()
        else:
            self.pomodoro_phase = 'focus'
            t = self.pomodoro_focus_time_edit.time()
        total = t.hour() * 3600 + t.minute() * 60 + t.second()
        self.pomodoro_paused_remaining = total
        self.pomodoro_end_time = time.monotonic() + total
        self.pomodoro_running = True
        self.pomodoro_paused = False
        self.pomodoro_pause_button.setText("Pause")
        self.pomodoro_status_label.setText(f"{self.pomodoro_phase.capitalize()} running...")
        self.pomodoro_update_display()

    # -----------------------------------------------------------------------
    # Exam Section (auto-cycling global clock)
    # -----------------------------------------------------------------------
    def setup_exam_section(self):
        self.exam_container = QtGui.QWidget()
        lay = QtGui.QVBoxLayout(self.exam_container)
        # FIXED: Tight spacing
        lay.setContentsMargins(2, 1, 2, 1)
        lay.setSpacing(1)

        lay.addWidget(self.create_title_label("Exam Clock"))

        self.exam_time_label = QtGui.QLabel("00:00:00")
        self.exam_time_label.setFont(self.font_display)
        self.exam_time_label.setAlignment(QtCore.Qt.AlignCenter)
        self.exam_time_label.setStyleSheet("background-color:#222;color:#00e5ff;padding:6px;border-radius:3px;")
        lay.addWidget(self.exam_time_label)

        self.exam_zone_label = QtGui.QLabel("(zone)")
        self.exam_zone_label.setFont(self.font_label)
        self.exam_zone_label.setAlignment(QtCore.Qt.AlignCenter)
        lay.addWidget(self.exam_zone_label)

        h = QtGui.QHBoxLayout()
        h.setSpacing(2)
        lbl = QtGui.QLabel("Cycle every:")
        lbl.setFont(self.font_label)
        h.addWidget(lbl)
        self.exam_cycle_spin = QtGui.QSpinBox()
        self.exam_cycle_spin.setRange(3, 60)
        self.exam_cycle_spin.setValue(5)  # default 5 seconds
        h.addWidget(self.exam_cycle_spin)
        lbl2 = QtGui.QLabel("sec")
        lbl2.setFont(self.font_label)
        h.addWidget(lbl2)
        lay.addLayout(h)

        # FIXED: Maximum height for exam section
        self.exam_container.setMaximumHeight(110)

        self.exam_switch.stateChanged.connect(self.exam_container.setVisible)
        self.exam_container.setVisible(False)
        self.main_layout.addWidget(self.exam_container)
        # FIXED: 1 row separator between sections
        sep_exam = QtGui.QFrame(frameShape=QtGui.QFrame.HLine)
        sep_exam.setFixedHeight(1)
        sep_exam.setFrameShape(QtGui.QFrame.HLine)
        sep_exam.setStyleSheet("QFrame { border: none; background-color: #555; }")
        self.main_layout.addWidget(sep_exam)

    def update_exam_clock(self):
        zones = list(GLOBAL_ZONES.items())
        if not zones:
            return

        cycle_sec = self.exam_cycle_spin.value()
        if cycle_sec <= 0:
            cycle_sec = 5
        now = time.monotonic()

        idx = int(now / cycle_sec) % len(zones)
        self.exam_zone_index = idx

        zone_name, offset = zones[idx]
        utc = datetime.datetime.utcnow()
        local = _apply_simple_dst(utc, zone_name, offset)

        self.exam_zone_label.setText(zone_name)
        self.exam_time_label.setText(local.strftime("%I:%M:%S %p"))

    # -----------------------------------------------------------------------
    # Alarm Checking Logic
    # -----------------------------------------------------------------------
    def check_alarm(self):
        if not self.alarm_enable_checkbox.isChecked():
            return

        zone = self.alarm_zone_selector.currentText()
        if zone == "Local":
            now = datetime.datetime.now()
        else:
            utc = datetime.datetime.utcnow()
            base_offset = GLOBAL_ZONES.get(zone, 0)
            now = _apply_simple_dst(utc, zone, base_offset)

        alarm_time = self.alarm_time_edit.time()
        alarm_dt = now.replace(hour=alarm_time.hour(), minute=alarm_time.minute(), second=0, microsecond=0)

        checked_days = [i for i, cb in enumerate(self.alarm_repeat_checkboxes) if cb.isChecked()]
        if not checked_days:
            # One-time alarm - check if we're within the trigger window BEFORE adjusting days
            time_diff = (now - alarm_dt).total_seconds()
            
            if 0 <= time_diff < 60:  # Within the alarm minute
                if self._alarm_last_fired_date != now.date():
                    print(f"[ALARM] *** TRIGGERING ONE-TIME ALARM *** at {now.strftime('%H:%M:%S')}")
                    self.trigger_alarm()
                    self._alarm_last_fired_date = now.date()
                    return
            
            # If alarm time has passed (more than 60 seconds), schedule for tomorrow
            if time_diff >= 60:
                alarm_dt += datetime.timedelta(days=1)
            
            if alarm_dt.date() == self._alarm_last_fired_date:
                return
        else:
            # Repeating alarm
            today_weekday = now.weekday()
            candidates = []
            for d in checked_days:
                days_ahead = (d - today_weekday) % 7
                candidate = alarm_dt + datetime.timedelta(days=days_ahead)
                if days_ahead == 0:
                    # Check if we should trigger today BEFORE adding 7 days
                    time_diff = (now - candidate).total_seconds()
                    if 0 <= time_diff < 60:
                        if self._alarm_last_fired_date != now.date():
                            print(f"[ALARM] *** TRIGGERING REPEATING ALARM *** at {now.strftime('%H:%M:%S')}")
                            self.trigger_alarm()
                            self._alarm_last_fired_date = now.date()
                            return
                    # If time has passed significantly, schedule for next week
                    if candidate <= now and time_diff >= 60:
                        candidate += datetime.timedelta(days=7)
                candidates.append(candidate)
            candidates.sort()
            next_alarm = candidates[0] if candidates else None
            if not next_alarm:
                return
            if next_alarm.date() == self._alarm_last_fired_date:
                return

    def update_alarm_remaining(self):
        if not self.alarm_enable_checkbox.isChecked():
            self.alarm_time_remaining_label.setText("")
            return

        zone = self.alarm_zone_selector.currentText()
        if zone == "Local":
            now = datetime.datetime.now()
        else:
            utc = datetime.datetime.utcnow()
            base_offset = GLOBAL_ZONES.get(zone, 0)
            now = _apply_simple_dst(utc, zone, base_offset)

        alarm_time = self.alarm_time_edit.time()
        alarm_dt = now.replace(hour=alarm_time.hour(), minute=alarm_time.minute(), second=0, microsecond=0)

        checked_days = [i for i, cb in enumerate(self.alarm_repeat_checkboxes) if cb.isChecked()]
        if not checked_days:
            if alarm_dt <= now:
                alarm_dt += datetime.timedelta(days=1)
            next_dt = alarm_dt
        else:
            today_weekday = now.weekday()
            candidates = []
            for d in checked_days:
                days_ahead = (d - today_weekday) % 7
                candidate = alarm_dt + datetime.timedelta(days=days_ahead)
                if days_ahead == 0 and candidate <= now:
                    candidate += datetime.timedelta(days=7)
                candidates.append(candidate)
            candidates.sort()
            next_dt = candidates[0] if candidates else alarm_dt

        diff = next_dt - now
        if diff.total_seconds() < 0:
            self.alarm_time_remaining_label.setText("")
            return

        total_seconds = int(diff.total_seconds())
        days_ahead_for_label = (next_dt.date() - now.date()).days
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        seconds = total_seconds % 60

        weekday_short = next_dt.strftime("%a")
        if days_ahead_for_label == 0:
            when_label = f"Today ({weekday_short})"
        elif days_ahead_for_label == 1:
            when_label = f"Tomorrow ({weekday_short})"
            # noqa
        else:
            when_label = weekday_short

        time_str = next_dt.strftime("%H:%M")
        self.alarm_time_remaining_label.setText(
            f"Next alarm: {when_label} {time_str} "
            f"(in {hours:02d}h {minutes:02d}m {seconds:02d}s)"
        )

    def trigger_alarm(self):
        idx = self.alarm_sound_selector.currentIndex()
        sound_file = None
        if 0 <= idx < len(self._alarm_sound_files):
            sound_file = self._alarm_sound_files[idx]
            
        if sound_file and os.path.isfile(sound_file):
            try:
                import winsound
                winsound.PlaySound(sound_file, winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_LOOP)
                print(f"Playing alarm: {sound_file}")
            except Exception as e:
                print(f"Alarm sound error: {e}")
        else:
            print("No valid alarm sound file selected")

        msg = QtGui.QMessageBox(self.form)
        msg.setWindowTitle("ALARM!")
        msg.setText("Time to wake up!")
        stop_btn = msg.addButton("Stop Alarm", QtGui.QMessageBox.AcceptRole)
        msg.addButton(QtGui.QMessageBox.Ok)
        msg.exec()
        if msg.clickedButton() == stop_btn:
            try:
                import winsound
                winsound.PlaySound(None, winsound.SND_PURGE)
            except:
                pass

    def on_alarm_settings_changed(self, *args):
        enabled = self.alarm_enable_checkbox.isChecked()
        self.alarm_status_label.setText("Alarm on" if enabled else "Alarm off")
        self._alarm_last_fired_date = None

    # -----------------------------------------------------------------------
    # Main Update Loop
    # -----------------------------------------------------------------------
    def update_all(self):
        if not self.form.isVisible():
            return

        try:
            self.update_local_clock()
            if self.clock_type_switch.currentIndex() == 1:
                self.update_global_clock()
            self.stopwatch_update_display()

            if self.countdown_running and not self.countdown_paused:
                rem = self.countdown_end_time - time.monotonic()
                if rem <= 0:
                    self.countdown_running = False
                    self.countdown_start_button.setEnabled(True)
                    self.countdown_pause_button.setEnabled(False)
                    self.countdown_status_label.setText("Finished!")
                    self.trigger_countdown_alarm()
                else:
                    self.countdown_update_display()
            else:
                self.countdown_update_display()

            if self.pomodoro_running and not self.pomodoro_paused:
                rem = self.pomodoro_end_time - time.monotonic()
                if rem <= 0:
                    ended_phase = self.pomodoro_phase
                    self._pomodoro_switch_phase()
                    self.trigger_pomodoro_sound(ended_phase)
                else:
                    self.pomodoro_update_display()
            else:
                self.pomodoro_update_display()

            if self.exam_switch.isChecked():
                self.update_exam_clock()

            self.update_project_selector_if_needed()
            self.check_alarm()
            self.update_alarm_remaining()
        except Exception as e:
            print(f"[UPDATE ERROR] {e}")

    def update_local_clock(self):
        now = datetime.datetime.now()
        self.local_time_label.setText(now.strftime("%I:%M:%S %p"))
        self.local_date_label.setText(now.strftime("%a %b %d"))

    def update_global_clock(self):
        zone = self.global_zone_selector.currentText()
        base_offset = GLOBAL_ZONES.get(zone, 0)
        utc = datetime.datetime.utcnow()
        # Apply simple DST for a few supported regions so Sydney, etc. match local.
        local = _apply_simple_dst(utc, zone, base_offset)
        self.global_time_label.setText(local.strftime("%I:%M:%S %p"))
        self.global_date_label.setText(local.strftime("%a %b %d"))

    def update_project_selector_if_needed(self):
        docs = self.get_open_documents()
        if docs != self.cached_document_list:
            self.cached_document_list = docs
            cur = self.project_selector.currentText()
            self.project_selector.blockSignals(True)
            self.project_selector.clear()
            self.project_selector.addItems(docs)
            idx = self.project_selector.findText(cur)
            if idx >= 0:
                self.project_selector.setCurrentIndex(idx)
            self.project_selector.blockSignals(False)

    # -----------------------------------------------------------------------
    # Misc Actions
    # -----------------------------------------------------------------------
    def _raise_dock_delayed(self):
        """Helper to raise dock after brief delay to prevent tab switching"""
        if self.dock_widget:
            QtCore.QTimer.singleShot(100, lambda: self.dock_widget.raise_())
    
    def edit_file_path(self):
        dlg = QtGui.QFileDialog(self.form)
        dlg.setAcceptMode(QtGui.QFileDialog.AcceptSave)
        dlg.setNameFilter("Excel Files (*.xlsx)")
        dlg.setDefaultSuffix("xlsx")
        # Set starting directory to current file location
        if os.path.exists(self.default_xlsx_path):
            dlg.setDirectory(os.path.dirname(self.default_xlsx_path))
        elif self.macro_directory_root and os.path.exists(self.macro_directory_root):
            dlg.setDirectory(self.macro_directory_root)
        if dlg.exec():
            self.default_xlsx_path = dlg.selectedFiles()[0]
            self.save_path_label.setText(self.get_display_path())
            self._pending_new_file = True
            self.status_label.setText("Path updated.")
        
        # Keep Clock tab visible after dialog
        if self.dock_widget:
            QtCore.QTimer.singleShot(100, lambda: self.dock_widget.raise_())

    def open_save_folder(self):
        folder = os.path.dirname(self.default_xlsx_path)
        os.makedirs(folder, exist_ok=True)
        try:
            if platform.system() == "Windows":
                os.startfile(folder)
            elif platform.system() == "Darwin":
                subprocess.Popen(["open", folder])
            else:
                subprocess.Popen(["xdg-open", folder])
        except Exception as e:
            QtGui.QMessageBox.warning(self.form, "Error", str(e))
        
        # Keep Clock tab visible after opening folder
        if self.dock_widget:
            QtCore.QTimer.singleShot(100, lambda: self.dock_widget.raise_())

    def view_logs(self):
        self.load_existing_data()
        dlg = QtGui.QDialog(self.form)
        dlg.setWindowTitle("Project Time Logs")
        dlg.resize(560, 420)
        lay = QtGui.QVBoxLayout(dlg)
        if not any(self.project_times.values()):
            lay.addWidget(QtGui.QLabel("No logs yet."))
        else:
            total_sec = sum(
                h * 3600 + m * 60 + s
                for proj in self.project_times.values()
                for dur in proj
                for h, m, s in [map(int, dur[0].split(':'))]
            )
            th, tm, ts = int(total_sec // 3600), int((total_sec % 3600) // 60), int(total_sec % 60)
            lay.addWidget(QtGui.QLabel(f"<b>Total:</b> {th:02d}:{tm:02d}:{ts:02d}"))
            txt = QtGui.QTextEdit()
            lines = []
            for proj, logs in self.project_times.items():
                if logs:
                    lines.append(f"=== {proj} ===")
                    lines.extend(f"  {dur} — {ts}" for dur, ts in logs)
            txt.setPlainText("\n".join(lines))
            txt.setReadOnly(True)
            lay.addWidget(txt)
        close_btn = QtGui.QPushButton("Close")
        close_btn.clicked.connect(dlg.accept)
        lay.addWidget(close_btn)
        dlg.exec()
        
        # Keep Clock tab visible after closing dialog
        if self.dock_widget:
            QtCore.QTimer.singleShot(100, lambda: self.dock_widget.raise_())

    def _toggle_preview_alarm_sound(self):
        try:
            import winsound
            if getattr(self, '_alarm_preview_playing', False):
                winsound.PlaySound(None, winsound.SND_PURGE)
                self._alarm_preview_playing = False
                self.alarm_sound_preview_btn.setText("Preview")
                return
            idx = self.alarm_sound_selector.currentIndex()
            if 0 <= idx < len(self._alarm_sound_files):
                path = self._alarm_sound_files[idx]
                if os.path.isfile(path):
                    winsound.PlaySound(path, winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_LOOP)
                    self._alarm_preview_playing = True
                    self.alarm_sound_preview_btn.setText("Stop")
                    print(f"Playing preview: {path}")
                else:
                    QtGui.QMessageBox.warning(self.form, "Error", "Sound file not found")
        except Exception as e:
            QtGui.QMessageBox.warning(self.form, "Error", f"Preview error:\n{e}")

    def cleanup(self):
        if self.timer.isActive():
            self.timer.stop()


# ====================================================================
# Macro Entry Point
# ====================================================================
if __name__ == '__main__':
    mw = Gui.getMainWindow()
    dock_name = "ProjectTimeTracker_Panel"

    old = mw.findChild(QtGui.QDockWidget, dock_name)
    if old:
        mw.removeDockWidget(old)
        old.deleteLater()

    panel = ProjectTimeTrackerPanel()
    dock = QtGui.QDockWidget("CLOCK", mw)
    dock.setObjectName(dock_name)
    
    # Store reference for operations that need to keep dock visible
    panel.dock_widget = dock
    
    # Proper dock features - no WindowStaysOnTopHint to avoid issues
    dock.setFeatures(QtGui.QDockWidget.DockWidgetMovable | 
                     QtGui.QDockWidget.DockWidgetFloatable |
                     QtGui.QDockWidget.DockWidgetClosable)
    
    dock.setWidget(panel.get_form())
    
    # Place as standalone dock on right side, NOT tabified
    mw.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
    
    # Show and ensure visible
    dock.show()
    dock.raise_()
    
    print("Clock & Time Tracker v2.0.4 Industry Quality loaded")
